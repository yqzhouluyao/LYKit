### 一、说说你对Objective-C中runtime的理解，在工作中有哪些应用？

运行时负责消息传递、对象动态创建、方法混合支持其动态性。

1、Swizzling允许交换方法实现，这有助于调试、测试

2、使用关联对象给分类添加属性

3、字典转模型

4、动态方法解析，可以在运行时给类添加方法

5、分类允许您在不更改原始类实现的情况下使用新方法





### 二、说说你对Objective-C中runloop的理解，在工作中有哪些应用？

runloop的主要目的是有任务处理时让线程忙碌起来，没有任务时让它休眠。

runloop是线程中的事件处理循环，这个事件循环会监听多种输入源，比如用户交互、网络事件、计时器事件、把这些事情调度给相应的处理者，确保主线程不被阻塞。

#### runloop的3种输入源：

1、port对象：他们能处理进程间通讯和异步消息

2、计时器：它们以特定的时间间隔或预定的时间触发。

3、用户界面事件：触摸事件、按钮点击和其他用户交互。

4、网络连接：异步 I/O 操作和网络通信。



#### runloop的一些应用：

1、RunLoop如何保证NSTimer在视图滑动时依然能正常运转

2、RunLoop如何保证不影响UI卡顿

3、检测卡顿

4、常驻线程



### 三、说说你对Objective-C中多线程的理解，有哪些多线程方案，针对每个方案的优劣进行分析？

#### 1、NSThread

在Objective-C中，NSThread是一个底级别的方法创建和管理线程，提供了一些面向对象的接口

##### 好处：

更容易控制线程管理和执行，更加的轻量级

##### 坏处：

需要手动管理比较复杂容易出错，需要仔细同步避免死锁。

##### 使用场景：   

如果您需要对线程进行细粒度控制并且不介意处理手动线程管理的复杂性，NSThread 可能是正确的选择。



#### 2、GCD

更高的抽象级别管理并发任务，用于系统调度队列去执行并发任务，让你可以聚焦任务的完成而不是线程管理

##### 好处：

简单的线程管理、自动管理线程池提高性能和资源利用率、支持串行和并发调度队列允许更好的控制任务的执行顺序。

##### 坏处：

相比NSThread对单个线程控制较少、C语言接口在面向对象语言Objective-C中使用起来不是那么自然

##### 使用场景：

 如果您更喜欢抽象线程管理并提供出色性能和资源管理的高级、易于使用的方法，那么 GCD 将是一个很好的选择。



#### 3、NSOperation and NSOperationQueue

GCD 相比，它们提供面向对象的多线程方法，并提供对任务执行和依赖性的更多控制。

##### 好处：

面向对象。

支持任务优先级和依赖性，允许复杂的执行场景。

可以与 KVO（Key-Value Observing）一起使用来监视操作状态，从而在管理任务时提供额外的灵活性。

##### 坏处：

开销更大，因为每个操作都是一个对象。

与 GCD 相比，可能需要更多样板代码来设置和管理操作。

##### 使用场景：

如果你想要一种允许复杂任务执行场景和依赖关系的面向对象方法，NSOperation 和 NSOperationQueue 将是最合适的选择。





### 四、说说你对Objective-C中内存管理的理解，哪些内存管理错误是比较常见的，是怎么解决的？

内存管理是 Objective-C 编程的一个重要方面。它涉及分配、跟踪和释放内存，以确保资源的高效使用并防止内存泄漏或崩溃。

Objective-C 使用引用计数来管理内存，这是基于保留计数的概念。

 在自动引用计数 (ARC) 之前，开发人员必须使用以下方法手动管理内存： retain, release, 和 autorelease.。随着 ARC 的引入，编译器通过插入适当的内存管理调用来自动管理内存。

Objective-C 对象存储在堆上，堆是为动态分配保留的内存区域。每个对象都有一个保留计数，它是一个整数值，表示对象的“所有者”或强引用的数量。当保留计数降为零时，将释放该对象，并释放其内存。

#### 哪些内存管理错误是比较常见的：

##### 1、Retain cycles

当两个或多个对象彼此具有强引用时，会发生保留循环，导致它们的保留计数永远不会达到零。这会导致内存泄漏，因为对象永远不会被释放。

##### 解决方案：

使用弱引用（使用 __weak 关键字声明）来打破保留循环。弱引用不会增加被引用对象的保留计数，并在被引用对象被释放时自动设置为 nil。

##### 2、Over-releasing

过度释放：当您尝试释放一个对象的次数超过它被保留的次数时，就会发生过度释放，导致保留计数降到零以下。这可以导致崩溃或未定义的行为，因为对象的内存可能会被释放并重新用于其他目的。

##### 解决方案：

对于 ARC，过度释放通常不是问题，因为编译器会自动管理内存。但是，如果您正在使用非 ARC 代码，请小心平衡保留和释放调用，并确保您释放对象的次数不会超过保留的次数。



##### 3、Dangling pointers

悬挂指针是对已被释放的对象的引用。访问悬空指针可能会导致崩溃或未定义的行为。

##### 解决方案：

为避免悬挂指针，使用ARC，它会自动管理内存并在被引用对象被释放时将弱引用设置为nil。如果您使用的是非 ARC 代码，则在释放对象时要小心，并确保在释放对象后将指针设置为 nil。



##### 4、Premature deallocation:

当一个对象在它仍在使用时被释放，导致它的保留计数下降到零并且它的内存被释放。 在对象被释放后访问它可能会导致崩溃或未定义的行为。

解决方案：使用 ARC，过早释放通常不是问题，因为编译器会自动管理内存。 在非 ARC 代码中，确保只要需要就保留对象，仅在不再使用时才释放它们。 请注意对象的所有权及其使用范围。



##### 5、Memory leaks:

当一个对象不再需要但由于其保留计数未达到零而未被释放时，就会发生内存泄漏。内存泄漏可能会导致您的应用程序消耗比必要更多的内存，从而导致性能不佳甚至因内存不足而崩溃。 

##### 解决方案：

使用Xcode中的性能分析和测试工具Instruments来检测和分析您的应用程序中的内存泄漏。寻找保留周期，确保正确使用强引用和弱引用，并遵循 Objective-C 中内存管理的最佳实践。





### 五、AutoReleasePool底层数据结构是什么？用在哪些场景

#### 使用场景：

它在处理大量临时对象时特别有用。自动释放池的底层数据结构本质上是一堆对象。

#### 内存管理原理：

 自动释放池通过允许将对象标记为自动释放来帮助管理内存。当一个对象被发送一个自动释放消息时，它被添加到当前的自动释放池中。自动释放池中的对象随后在池耗尽时被释放（即，它们的保留计数减一）。这通常发生在当前运行循环周期结束时，尽管自动释放池也可以手动创建和清空。 自动释放池可以嵌套，每个嵌套的池形成一个堆栈。当自动释放池被耗尽时，它会释放当前池和所有内部嵌套池中的所有对象。 使用自动引用计数 (ARC)，自动释放池是使用 @autoreleasepool 块创建的。在此块范围内自动释放的对象将添加到与该块关联的自动释放池中。当块退出时，自动释放池被清空，池中所有对象的保留计数都减一。



#### AutoReleasePool底层数据结构是什么？

自动释放池可以为对象存储的内存量不受固定大小的限制。相反，自动释放池根据需要动态分配内存来存储标记为自动释放的对象。 在幕后，自动释放池使用基于页面的数据结构来存储对象。创建自动释放池时，它从初始页面开始。每个页面都有固定的大小，由系统的内存页面大小决定（通常为4KB或16KB）。当自动释放池的当前页面已满时，将分配一个新页面并将其链接到前一页，从而创建一个页面链表。 对象以后进先出 (LIFO) 的顺序添加到自动释放池中。当自动释放池被耗尽时，它遍历页面链表，以相反的顺序释放对象。当自动释放池耗尽或应用程序终止时，页面占用的内存将被释放。 





### 六、你在开发项目中使用CI/CD是怎么用的，有哪些不同的方案，Jenkins 自动化打包用过吗，怎么选择适合你的方案？

#### 1、Xcode Server

Xcode Server 是 Apple 内置于 Xcode 中的集成 CI/CD 解决方案。它允许您使用自己的 Mac 硬件为您的 iOS 项目设置自动构建和测试。

#### 创建一个bot:

过选择适当的分支并在需要时提供必要的身份验证来配置存储库设置。

 配置构建设置，例如构建方案、构建配置和任何构建参数。

 通过选择要在其上运行测试的设备和模拟器来设置测试。 

通过选择配置文件和证书来配置代码签名， 保存机器人配置。

####  管理和监控bot：

 使用 Xcode 的“Report Navigator”查看机器人的状态、查看集成日志并分析测试结果。 

安排集成以特定时间间隔自动运行或手动触发它们。 配置通知以接收有关机器人状态、集成结果和测试失败的更新。





#### 2、Jenkins

Jenkins 是一个流行的开源 CI/CD 平台，支持 iOS 项目。它提供了广泛的插件和集成，允许进行广泛的定制。

#### Create a Jenkins job:

在“Build”部分，添加一个构建步骤并选择“Invoke Xcode”。

 配置构建设置，例如构建方案、构建配置和任何构建参数。 

如果要运行测试，请使用适当的 xcodebuild 命令添加“执行 shell”构建步骤以进行测试（例如，xcodebuild -scheme YourScheme -destination 'platform=iOS Simulator,name=iPhone 8,OS=latest' test）。

 配置构建后操作，例如归档工件、发布测试结果或触发其他作业。



#### Manage and monitor jobs:

使用 Jenkins 仪表板监控作业状态、查看构建日志和分析测试结果。

 安排构建自动运行，例如，通过基于轮询源代码控制存储库或使用 webhook 设置构建触发器。 

配置通知以接收构建状态、测试结果和失败的更新。



#### 3、GitLab CI/CD

GitLab 提供内置的 CI/CD 管道，可用于自动构建、测试和部署 iOS 应用程序。您可以设置自定义工作流程并与各种工具和服务集成。

#### 4、GitHub Actions

GitHub Actions 是集成到 GitHub 平台中的 CI/CD 解决方案。您可以使用 GitHub 提供的 macOS 运行器创建自定义工作流来构建、测试和部署您的 iOS 应用程序。







### 七、Instrument在iOS开发中能做哪些事，在项目中使用Instrument能做哪些性能优化的工作，比如如何追踪线程和 CPU 使用，监控网络和磁盘使用，发现弃用内存、内存泄漏和 zombie 对象， 分析耗电日志？

#### 1、Track thread and CPU usage

使用 Time Profiler 工具分析 CPU 使用情况并识别代码中的性能瓶颈。

 该仪器记录堆栈跟踪并帮助您了解哪些方法消耗的 CPU 时间最多。 

您可以使用调用树视图来探索调用层次结构并确定优化机会。



#### 2、Monitor network and disk usage

使用网络工具跟踪网络请求、数据传输和连接延迟。 

该仪器可帮助您识别缓慢或过多的网络请求并优化应用程序的网络性能。 

使用文件活动工具监视文件读取、写入和其他磁盘操作。 

该仪器可帮助您识别低效的磁盘访问模式并优化应用程序的磁盘使用。



#### 3、Discover abandoned memory, memory leaks, and zombie objects

abandoned memory：使用 Leaks instrument 检测应用程序中的内存泄漏。 该仪器可帮助您识别未释放的对象，从而导致内存使用量增加。

memory leaks： 使用Allocations instrument 来跟踪内存分配和释放。 该仪器可深入了解应用程序的内存使用情况，帮助您识别废弃的内存并优化内存管理。

zombie objects： 使用 Zombies instrument 检测僵尸对象（即已被释放但仍在访问的对象）。 该工具可帮助您查找和修复与访问已释放对象相关的问题，这些问题可能导致崩溃或未定义的行为。



#### 4、Analyze energy consumption

使用 Energy Log instrument 跟踪您的应用程序在设备上的能耗。 

该仪器记录与能源相关的事件，例如 CPU 利用率、屏幕亮度和网络活动，帮助您确定可以优化应用能源使用的领域。



### 八、MVP架构用过吗？它的核心设计思想是什么？你在项目中怎么用的？

Model-View-Presenter (MVP) 架构的核心设计思想是通过将应用程序分为三个不同的组件来分离应用程序中的关注点：Model、View 和 Presenter。这种关注点分离增强了应用程序的可维护性、可测试性和可伸缩性。

#### Model:

表示应用程序的底层数据和业务逻辑。它负责数据检索、存储和处理。 Model 独立于用户界面，不了解 View 或 Presenter。



#### View: 

代表用户界面，负责显示Presenter提供的数据。 View 是被动的，只处理用户输入并将其转发给 Presenter。



#### Presenter: 

充当模型和视图之间的中介。它从模型中检索数据、处理数据并更新视图。 Presenter 还处理来自 View 的用户输入并相应地更新 Model。



#### 优点：

##### 明确的关注点分离：

Model、View 和 Presenter 彼此独立，促进了干净的架构。

##### 可测试性：

无需 UI 组件即可轻松测试 Presenter。

##### 灵活性：

MVP 允许更灵活地处理 UI 事件和交互，因为 Presenter 明确负责管理 UI。



#### 缺点：

##### 增加样板代码：

MVP 可能需要更多样板代码，因为 Presenter 需要显式处理 UI 事件并更新 View。

##### Presenter 和 View 紧密耦合：

Presenter 通常与特定的 View 紧密耦合，这会限制其可重用性。



#### 适合的场景：

使用需要复杂 UI 交互和事件处理的应用程序时。

当您想要更明确地控制 UI 更新和事件处理时。 

使用不支持数据绑定的 UI 框架或数据绑定不是优先事项时。





### 九、MVVM架构用过吗？它的核心设计思想是什么？你在项目中怎么用的？

#### Model:

表示应用程序的底层数据和业务逻辑。它负责数据检索、存储和处理。 Model 独立于用户界面，不了解 View 或 ViewModel。



#### View: 

表示用户界面，负责显示 ViewModel 提供的数据。 View 是被动的，只处理用户输入并将其转发给 ViewModel。



#### ViewModel: 

充当模型和视图之间的中介。它从模型中检索数据，对其进行处理，并将其公开给视图。 ViewModel 还处理来自 View 的用户输入并相应地更新 Model。



#### 优点：

明确的关注点分离：Model、View 和 ViewModel 彼此独立，促进了干净的架构。

 增强的可测试性：无需 UI 组件即可轻松测试 ViewModel。 

数据绑定：MVVM 支持数据绑定，可以减少更新 UI 所需的代码量，简化 View 和 ViewModel 之间的通信。

可重用性：ViewModel 可以跨不同的视图重用，因为它没有与特定视图紧密耦合。



#### 缺点：

复杂性：由于数据绑定和额外的 ViewModel 层，MVVM 的设置和理解可能会更加复杂。

性能：数据绑定会带来性能开销，尤其是在处理大型数据集或复杂的 UI 时。



#### 适合的场景：

使用需要高度 UI 响应和频繁 UI 更新的应用程序时。

当您想跨多个视图或平台（例如 iOS 和 macOS）重用 ViewModel 时。

使用支持数据绑定的 UI 框架（例如 SwiftUI）时。



MVVM 和 MVP 之间最大的区别在于它们处理 UI 更新以及 View 和底层逻辑（ViewModel 或 Presenter）之间的通信的方式。 MVVM 依靠数据绑定来更新 UI，而 MVP 使用显式方法，Presenter 更新 View。



### 十、将依赖库二进制化降低编译时间30%具体是怎么做的？



### 十一、iOS安装包大小减少约50%,具体是怎么做的？



### 11、聊聊你对组件化的理解，有哪些方案他们的设计思想分别是什么，你们用的是什么方案，它的好处是什么？



### 12、用ARKit和Machine Learning 做过什么项目，怎么做的？



### 13、图文混排怎么做的， YYLabel 实现题库的图文混排？



### 14、如何解析m3u8索引文件，实现加密 TS 切片的本地服务器播放和远程服务器播放的？



### 15、SQLite 数据库迁移、表扩充字段是这么做的？



### 16、使用 AssociatedObject和 Notification 实现动态切换主题颜色及图片怎么做的？



### 17、弹幕库是如何开发的，设计思想及实现逻辑？



### 18、WKWebView 与原生页面混合开发在哪些场景，ScrollView的高度是怎么算的，监听webview的content.Size准吗？JS与 OC 是怎么交互的？



### 19、纪念日置灰功能是怎么做的？



### 20、使用 Socket 实现音视频数据收发，是怎么做的，开启了几个线程，epoll是什么？



### 21、音视频硬编码、硬解码是怎么做的？硬编码硬解码用的是H265还是H264?为什么不用H265?



### 22、音视频同步是怎么做的？



### 23、音频重采样指的是什么？怎么做的？有哪些应用场景？



### 24、音视频通讯库的延迟是多少，怎么降低延迟的？
