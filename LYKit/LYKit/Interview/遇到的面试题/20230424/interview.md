### 一、一个颜色值设置在UIView上，在iOS屏幕上被加载出来，整个显示的过程是什么样的？

1、设置颜色值：使用 backgroundColor 属性将颜色值分配给 UIView。

2、设置颜色值时将视图标记为需要布局。这会触发自动布局系统重新计算视图层次结构中视图的位置和大小。

3、将视图标记为需要显示：布局计算完成后，将视图标记为需要显示。这意味着绘图系统被通知需要在屏幕上重新绘制视图。

4、应用程序的main runloop负责处理用户输入、更新 UI 和管理其他应用程序事件。当运行循环检测到需要显示视图时，它会安排绘图过程。

5、核心动画用于被创建处理更新图层，事务组确保动画能够一起被更新。

6、渲染：UIKit 框架与 Core Animation 一起渲染视图层次结构。

视图层是一个 CALayer 对象，负责管理视觉内容，包括背景颜色。

层的内容使用 Core Graphics 或 OpenGL 绘制，具体取决于设备和渲染引擎。

7、合成：一旦渲染了视图层次结构中的所有层，它们就会被合成到一个缓冲区中。这是由 GPU 完成的，GPU 根据图层的属性，混合和组合图层。

8、显示帧：合成后，最终帧显示在屏幕上。 iOS 系统管理帧缓冲区并以一致的帧速率显示内容，通常为每秒 60 帧。



### 二、子类里面进行了方法声明，但是没有方法实现，交换方法之后会出现栈溢出的情况吗？

当程序耗尽其调用堆栈内存时，就会发生堆栈溢出。这通常是由于过多的递归或深度嵌套的函数调用而发生的，其中每个新函数调用都会分配一个新的堆栈帧，最终导致堆栈的内存限制被超出。

如果无限循环导致增加调用堆栈的重复函数调用，则它会导致堆栈溢出。例如，如果无限循环触发递归函数而没有适当的基本情况，堆栈将无限增长，最终导致堆栈溢出。



### 三、KVO派生类的释放时机？

使用 -addObserver:forKeyPath:options:context: 方法添加观察者时会生成派生类。

已使用 -removeObserver:forKeyPath: 或 -removeObserver:forKeyPath:context: 方法删除了所观察属性的所有观察者。 原始类的观察实例被释放。

原始类的观察实例被释放。

在释放被观察对象之前移除观察者是至关重要的，因为不这样做会导致崩溃或意外行为。在Objective-C中，可以在被观察类的-dealloc方法中移除观察者，而在Swift中，可以使用deinit方法或者添加观察者时返回的NSKeyValueObservation对象。

请记住，派生类的生命周期由运行时管理，您不应尝试直接管理它。专注于正确添加和删除观察者，以确保 KVO 在您的应用程序中按预期工作。



### 四、分类的加载时机？

这发生在调用 main 函数之前和创建任何类实例之前。

Objective-C 中的类别是一种无需子类化即可向现有类添加方法的方法。

当应用程序启动时，动态链接器 (dyld) 将应用程序可执行文件的二进制映像和任何链接的动态库（包括系统框架）加载到进程的地址空间中。

Objective-C 运行时扫描二进制 image 并注册它找到的任何类和类别。在此过程中，运行时将类别中的方法与原始类实现合并。

### 五、如何对视频播放的过程进行埋点，比如拖拽，切换分辨率

这是使用 AVPlayer 和 NotificationCenter 观察和记录视频播放事件的一般方法：

观察并记录拖动和切换分辨率事件

要记录拖动事件，您可以在自定义 AVPlayerViewController 子类中实现自定义滑块

切换分辨率：通过观察 AVPlayerItem 的 tracks 属性并监视对视频轨道的 naturalSize 的更改来记录分辨率更改事件。您可以使用 KVO（Key-Value Observing）来观察这些变化，并在分辨率变化时记录事件。





### 六、在iOS中音视频传输通讯的过程中，丢包恢复是怎么做的？

1、前向纠错 (FEC)：FEC 将冗余数据添加到传输的数据包中，即使部分数据包丢失，接收方也可以恢复原始数据。

这种方法增加了带宽使用，但提供了一种无需重新传输即可从数据包丢失中恢复的方法

2、自动重复请求 (ARQ)：ARQ 是一种接收方向发送方发送有关丢失数据包的反馈的技术。然后发送方重新传输丢失的数据包以确保正确接收所有数据。这种方法会增加延迟，尤其是在高延迟网络中，但它有助于恢复丢失的数据。

3、实时传输协议 (RTP) 和实时控制协议 (RTCP)：RTP 是一种广泛使用的传输实时音频和视频数据的协议。 它通常与 RTCP 一起使用，提供带外控制信息和数据分发质量反馈。 RTCP 可以通知发送方有关数据包丢失的信息，允许发送方根据需要调整其传输速率、调整 FEC 参数或重传丢失的数据包。

4、自适应比特率流：为了应对不断变化的网络条件，自适应比特率流动态调整音频和视频流的质量和比特率。通过降低质量和比特率以匹配可用带宽并最大程度地降低进一步丢包的风险，即使在丢包的情况下，这也有助于保持流畅的用户体验。

5、抖动缓冲区：接收端的抖动缓冲区可以通过临时存储传入数据包并以平滑一致的方式播放它们来帮助减轻数据包丢失的影响。这有助于隐藏数据包丢失的影响并保持音频和视频质量，但它可能会引入额外的延迟。



### 七、M3U8相对于其他的方案有没有好处？

M3U8 不是单独的流媒体解决方案或协议，而是在 HTTP 直播流媒体 (HLS) 上下文中使用的播放列表文件格式。

HLS 是 Apple 开发的一种广泛使用的自适应流媒体协议。

M3U8 文件用作 HLS 协议的一部分，以提供作为视频流一部分的媒体文件片段列表（通常为 .ts 格式）。

在视频点播 (VOD) 场景中，使用 HLS（以及扩展的 M3U8）的主要优势在于其广泛的支持和适应性。 HLS 受各种平台支持，包括 iOS、Android 和许多 Web 浏览器，使其成为向各种设备交付视频内容的可靠选择。

#### 优势：

1、广泛的兼容性：HLS 在 iOS 和 macOS 设备上得到原生支持，它还通过使用媒体源扩展 (MSE) 与 Android 和大多数现代网络浏览器兼容。

2、自适应流式传输：HLS 支持自适应比特率流式传输，允许视频播放器根据观看者的网络状况在不同质量级别之间自动切换。这确保了流畅的播放体验和高效的带宽利用。

3、加密和 DRM 支持：HLS 支持使用 AES-128 进行内容加密，它还可以与各种数字版权管理 (DRM) 系统集成以保护优质内容。

4、对网络波动的弹性：HLS 流通过 HTTP 传输，这使得它们对网络波动更具弹性，并且更容易通过内容交付网络 (CDN) 进行缓存和分发。



#### 劣势：

1、延迟：HLS 使用分段文件进行流式传输，与 WebRTC 或低延迟 CMAF 等其他流式传输协议相比，这可能会引入更高的延迟。对于低延迟至关重要的直播场景，这可能并不理想。

2、编解码器限制：HLS 主要使用 H.264 视频编解码器和 AAC 音频编解码器，它们可能不是适用于某些类型视频内容的最高效编解码器。尽管 HLS 可以支持其他编解码器，如 H.265 和 VP9，但它们在设备和浏览器中的支持并不广泛。 

3、复杂性：实施和维护 HLS 流媒体解决方案可能比使用单一视频文件格式更复杂，尤其是在考虑自适应流媒体、加密和 DRM 等因素时。



M3U8 是一种在 HLS 协议中使用的播放列表文件格式。 HLS 是 VOD 场景的热门选择，因为它具有广泛的兼容性、自适应流媒体功能以及对加密和 DRM 的支持。但是，它也有一些缺点，例如较高的延迟和编解码器限制，这可能会使其他流媒体解决方案更适合某些场景。



### 八、说说swift的optional与objective-c中的常量有什么区别？

在 Swift 中，late 和 optional 与处理可选值和初始化属性有关。 Objective-C 常量用于声明在初始化后不能更改的常量值。

Swift 可选：Swift 中的可选用于表示可能存在或可能不存在的值。可选项可以有一个值或为零。可选类型用问号 ?按照类型。这使您能够安全地处理可能缺少值的情况，而不会由于意外的 nil 值而导致运行时崩溃。

Objective-C 常量：在 Objective-C 中，常量用于声明初始化后不能更改的值。 Objective-C 中有两种类型的常量： 整数、浮点数和字符等简单类型的常量使用 const 关键字声明：

